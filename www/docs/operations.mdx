---
id: operations
title: Operations
---

In the introduction, we saw how to replace `async/await` by writing equivalent
code in Effection. We can do this because there are strong analogues between the
way both systems work. However, there are also two key differences that
ultimately make Effection far more robust at handling asynchrony, and in this
section we'll unpack these differences in more detail. In summary: operations
are stateless, and they can be cancelled with grace.

### Stateless

The fundamental unit of abstraction for `async/await` is the `Promise`. They can
be created independently or with an [async function][], but either way,
`Promise` is stateful and will make progress on its own.

If you run the following snippet, it will immediately print `Hello World!` to
the console whether we `await` the result of `sayHello()` or not.

```javascript
async function sayHello() {
  console.log("Hello World!");
};

sayHello();
```

By contrast, the following will never print anything no matter how long we wait:

```javascript
function *sayHello() {
  console.log("Hello World!");
};

sayHello();
```

This is because unlike promises, Operations do not do anything by themselves.
Instead, they describe what should be done when the operation is run.

### Running Operations

In the example above, the generator function contains a recipe that says "log
'Hello World' to the console", but it does not actually execute that recipe
itself. We need something else to actually do that.

The simplest way is with the aptly named
[`run()`][run] function. Here it's used to execute the example above:

```javascript
import { run } from 'effection';

run(function* sayHello() {
  console.log("Hello World!");
});
```

This will print `Hello World!` to the console, just as you'd
expect.

The return value we get from `run` is a `Task`. A `Task` is both an operation
and a promise, so we can use it with `await` to integrate Effection into
existing `async/await` code.

```javascript
import { run } from 'effection';

try {
await run(function*() {
  throw new Error('oh no!');
})
} catch (error) {
  console.error(error);
}
```

In addition to `run()`, there is the `main()` function which we
already met in the introduction.  It takes care of a few critical
things for you like ensuring that the operation it's running is halted
when the process or browser shuts down, and printing errors to the
console in case anything goes wrong. If you're writing a program with
Effection from scratch, you should most likely use `main()` as the
entry point. `run()` is more bare-bones, and should only be used when
you need more fine grained control.

Using `main()`, our example looks like this:

```javascript
import { main } from 'effection';

await main(function*() {
  throw new Error('oh no!');
});
```

Instead of needing to catch the error like we did before, `main()`
will handle it for us, including printing it to the console.

### Composing Operations

Entry points like `run()` and `main()` are used usually once at the very
beginning of an Effection program, but the easiest and most common way to
run an operation is to include it in the body of another operation. To do this,
we use the `yield*` keyword, which is the Effection equivalent of `await`.

For example, the `sleep()` operation pauses execution for a specified duration
before resuming. We can call it from any operation using `yield*`;

```javascript
import { main, sleep } from 'effection';

await main(function*() {
  yield* sleep(1000);
  console.log("Hello World!");
});
```

Or, it can be embeded in an operation which itself is embedded in another
operation:

```javascript
import { main, sleep } from 'effection';

function* makeSlow(value) {
  yield* sleep(1000);
  return value;
}

await main(function*() {
  let text = yield* makeSlow('Hello World!');
  console.log(text);
});
```

There is no limit to the number of operations that can be nested within
each other, and in fact, composition is so core to how operations work that
_every operation in Effection eventually boils down to a combination of
just three primitive operations_: `action()`, `resource()`, and `suspend()`.

### Cancellation and Cleanup

Perhaps the most critical difference between promises and operations is that
once started, a promise will always run to completion no matter how long that
takes. Unfortunately, this makes the guarantees of structured concurrency
impossible to provide automatically. Operations, on the other hand, can be
interrupted at any time which means that we never have to worry about them
staying longer than they are absolutely needed.

Let's consider a hypothetical sleep function implemented using `async/await`. It
uses `setTimeout()` to resolve a promise once the sleep time has elapsed.

```js
async function sleep(duration) {
  await new Promise(resolve => setTimeout(resolve, duration));
}
```

We can now write our slow hello world program using this version:

```js
async function main() {
  await sleep(1000);
  console.log("Hello World!");
}

await main();
```

This logs `"Hello World!"` to the console after a delay of 1s, and so it works
as expected when we run it... sort of.

But what happens when you want to halt your sleep operation? Or more commonly,
what happens when you no longer care about the outcome of your sleep operation?

To understand why this might be, let's ask ourselves how long the program should
take to execute in Node JS?

```js
async function sleep(milliseconds) {
  await new Promise(resolve => setTimeout(resolve, milliseconds));
}

await Promise.race([sleep(10), sleep(10_000)]);
```

If you guessed 10 seconds, then you are technically correct! But if your
intuition told you that the answer _should_ be 10 milliseconds, then
congratulations, you are also correct!

Our intuition tells us that the answer should be 10 milliseconds because when
we race two promises against each other, and one of them wins, we don't care
what happens to the other one. The result is now definitively known and so we
can safely ignore all the other also-rans because they have absolutely no
bearing on the outcome of the computation. But in this case, because the 10
second sleep still has a pending `setTimeout()` callback installed, the run loop
cannot exit, and even though we have absolutely nothing else to do, we're forced
to wait around twiddling our thumbs until the timeout expires.

By contrast, the equivalent code in Effection will exit immediately after 10ms
as we expect.

```js
import { sleep, race, main } from "effection";

await main(function*() {
  yield* race([sleep(10), sleep(10_000)]);
});
```

This is because every operation in Effection can be interrupted at any moment
and as a result any cleanup code associated with that operation will be executed
immediately.

If we look at the implementation of the `sleep()` operation in Effection, we can
see how this works. It uses two of the fundamental operations:
`action()`, and `suspend()`, to wait until the duration has elapsed.

```js {6-8} showLineNumbers
export function sleep(duration) {
  return action(function* (resolve) {
    let timeoutId = setTimeout(resolve, duration);
    try {
      yield* suspend();
    } finally {
      clearTimeout(timeoutId);
    }
  });
}
```

But the critical difference between this implementation and our
original promise-based one is that the code inside the `finally` block will
run in _all cases_, no matter if the timeout is fired and the action resolves,
or whether the operation is halted while it is still suspended. There is more
detail how this works in the section on [operation scope and
lifecycle][scope].

However, the key takeaway here is that ___Operations seemlessly bundle
setup and teardown into composable units___ which allows cleanup to happen
relentlessly; leaving the programmer free to not worry about it.

[async function]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function
[promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise
[task]: https://frontside.com/effection/api
[run]: https://frontside.com/effection/api
[scope]: ./scope
